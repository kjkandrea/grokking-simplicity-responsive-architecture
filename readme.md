# 함수형 코딩 : 반응형 아키텍처

반응형 아키텍처는 효과(effect)와 그 효과에 대한 원인을 분리해서 코드에 복잡하게 꼬인 부분을 풀 수 있습니다.

반응형 아키텍처의 본질은 **원인과 효과** 의 결합을 분리하는 것입니다.

5개의 원인과 4개의 결과가 있을때 순차적인 단계를 따라 프로그래밍 한다면 시스템의 복잡도는 5 * 4 가 됩니다.
전통적인 n * m 문제 입니다.

반응형 아키텍처는 관리해야 할 것이 늘어나는 문제를 곱셈에서 덧셈으로 바꿀 수 있습니다. 5 개의 원인과 4 개의 결과가 있기 때문에 5 + 4 로 만들 수 있습니다.

## 감시자 (watcher)

감시자는 상태가 바뀔때마다 실행되는 **핸들러 함수** 입니다.

감시자 (watcher) 개념은 다른 이름으로 사용하기도 합니다.\
다음은 감시자의 다른 이름입니다.

* 감시자 (watcher)
* 이벤트 핸들러 (event handler)
* 옵저버 (observer)
* 콜백 (callback)
* 리스너 (listener)

모두 같은 개념을 나타내는 이름입니다. 어떤 것이 더 올바른 이름이라고 할 수 없습니다.

## 상태를 일급으로 관리합니다.

다음은 변경 가능한 값을 일급으로 만드는 코드입니다.

* [ValueCell](./src/calculator/cell/state/ValueCell.ts)

* `val()` : 값을 읽습니다.
* `update()` : 현재 값을 바꿉니다.
* `addWatcher()` : 값이 변경되었을때 호출 될 감시자를 추가합니다. 

## 파생된 값을 계산합니다.

다음은 ValueCell 을 토대로 파생된 값을 계산하는 코드입니다.

* [FormulaCell](./src/calculator/cell/state/FormulaCell.ts)
* [CompositionCell](./src/calculator/cell/state/CompositionCell.ts)

두 기본형은 값을 직접 바꿀 수 없습니다. 감시하던 상위(upstream) 셀 값이 바뀌면 값이 바뀝니다.
상위 셀이 바뀌면 상위 값을 가지고 셀 값을 다시 계산합니다.

* `val()` : 값을 읽습니다.
* `addWatcher()` : 값이 변경되었을때 호출 될 감시자를 추가합니다.
